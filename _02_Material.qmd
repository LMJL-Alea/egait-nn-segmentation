# Material {#sec-material}

In this work, the objective is to detect right and left heel strike and toe off events from hip orientation data over time. Knowledge of the occurences of these events is critical to compute key gait parameters such as the mean and the variability of stride duration, metrics of asymmetry or ratio stance/swing which have been proven to be clinically relevant [@annweiler2009risk;@beauchet2016poor]. We propose to address this problem by training, tuning and comparing several supervised classification models. In details, we consider the timepoints as the statistical units (observations) and we aim at training models to affect a *label* to each of them. This requires to elaborate a *labelled gait data* set in which we know which timepoints correspond to the occurence of the key gait events.

For this purpose, we used two sources of data. First, we clipped a 9-axis inertial measurement unit (IMU) at the level of the right hip and measured its orientation (that we assimilate to the hip orientation) over time during walking sessions. The data is recorded in the form of a unit quaternion time series. @sec-quaternions provides a brief overview of unit quaternions and their properties. Second, we used a pressure-sensitive walkway (GAITRite® mat) as a gold standard to record the occurences of the gait events of interest. @sec-data-acquisition elicits the data acquisition protocol while @sec-imu-data and @sec-gaitrite-data summarize the two collected data sets and the elaboration of the final labelled data set.

## Unit quaternions {#sec-quaternions}

Unit quaternions can be used to represent the 3D rotation of an object over time [@hamilton1844;@voight2021quaternion]. This representation has several advantages such as being the most compressed representation of rotation and avoiding the gimbal lock issue. We therefore chose to measure the sensor orientation as a unit quaternion.

Quaternions are four-dimensional vectors denoted by $\mathbf{q} = \left( q_w, q_x, q_y, q_z \right)$, but can also be viewed as hypercomplex numbers of rank $4$. Unit quaternions have a norm of $1$ and encode a 3D rotation with rotation angle $\theta \in [0, 2\pi]$ and rotation axis $\mathbf{u} = (u_x, u_y, u_z) \in S^2$, where $S^2$ is the 2-sphere, using the following formula:

$$
\mathbf{q} = \left( q_w, q_x, q_y, q_z \right)
= \cos \left( \frac{\theta}{2} \right) + \left( u_x i + u_y j + u_z k \right) \cdot \sin \left( \frac{\theta}{2} \right),
$$ {#eq-quaternions}

where $i$, $j$, and $k$ generalize the imaginary number $i$ and are such that $i^2 = j^2 = k^2 = ijk = -1$. Note that it is straightforward to show quaternions define through @eq-quaternions have unit norm.

The set of unit quaternions, denoted by $\mathbb{H}_u$, has a number of interesting properties. First, the quaternions $\mathbf{q}$ and $-\mathbf{q}$ represent the same rotation making $\mathbb{H}_u$ a double coverage of the space $\mathrm{SO}_3(\mathbb{R})$ of 3D rotations. Also, $\mathbb{H}_u$ forms a Lie group which is a group and a differentiable Riemannian manifold. As a group, it is in particular equipped with an identity element $\mathbf{q}^{(0)} = (1,0,0,0)$ which corresponds to the identity rotation, such that, for any $\mathbf{q} \in \mathbb{H}_u$, we have $\mathbf{q} \mathbf{q}^{(0)} = \mathbf{q}^{(0)}\mathbf{q} = \mathbf{q}$ and with a composition law $\circ$ given by the Hamilton product:

$$
\begin{aligned}
\mathbf{q}_1 \circ \mathbf{q}_2 = ( &q_{1w} q_{2w} - q_{1x} q_{2x} - q_{1y} q_{2y} - q_{1z} q_{2z}, \\
&q_{1w} q_{2x} + q_{1x} q_{2w} + q_{1y} q_{2z} - q_{1z} q_{2y}, \\
&q_{1w} q_{2y} - q_{1x} q_{2z} + q_{1y} q_{2w} + q_{1z} q_{2x}, \\
&q_{1w} q_{2z} + q_{1x} q_{2y} - q_{1y} q_{2x} + q_{1z} q_{2w}).
\end{aligned}
$$ {#eq-hamilton-product}

This is known as quaternion multiplication and, for simplicity, the symbol $\circ$ is often omitted and we simply write $\mathbf{q}_1 \mathbf{q}_2$. Note that the composition law is not commutative. As such, $\mathbb{H}_u$ is an Abelian group. The inverse of a unit quaternion $\mathbf{q}$ is given by its conjugate $\mathbf{q}^{-1} = \mathbf{q}^\star = (q_w, -q_x, -q_y, -q_z)$.

As a differentiable Riemannian manifold, it is also equipped with a natural distance, known as the *geodesic distance*, that can be used to measure the distance between two unit quaternions. For any two quaternions $\mathbf{q}_1$ and $\mathbf{q}_2$, it reads:

$$
d_g \left( \mathbf{q}_1, \mathbf{q}_2 \right) = \left\| \ln \left( \mathbf{q}_1^{-1} \mathbf{q}_2 \right) \right\| = \arccos \left( 2 \left( \mathbf{q}_1 \cdot \mathbf{q}_2 \right)^2 -1 \right),
$$ {#eq-geodesic-distance}

where the unit quaternion logarithm is defined as $\ln(\mathbf{q}) = \mathbf{u} \dfrac{\theta}{2}$.

In our application, the sensor orientation is the rotation between the reference frame of origin, here the Earth's reference frame $R_f=(f_1, f_2, f_3)$ and its own reference frame $R_s=(s_1, s_2, s_3)$ formed by the accelerometer, gyroscope, and magnetometer (see @fig-sensor-axis).

![Sensor reference and axis. [@drouin2023semi]](images/sensor-axis.png){#fig-sensor-axis width=200}

A *quaternion time series* (QTS) is an ordered set $\mathbf{Q}$ of unit quaternions along a temporal grid $t_1 < t_2 < \dots < t_p$. We will denote by $\mathbf{q}_{j} = \mathbf{Q}(t_j)$ the unit quaternion of the QTS $\mathbf{Q}$ recorded at time $t_j$. In our application, it represents the orientation of the hip at that time.

## Data acquisition {#sec-data-acquisition}

We used an IMU sensor to record the hip orientation over time. The IMU was composed of a 3-axis accelerometer, a 3-axis gyroscope and a 3-axis magnetometer. Subjects were wearing the sensor on their right hip (see @fig-sensor-position). The frequency of the sensor is $100$ Hz which corresponds to recording its orientation every $10$ ms. With this device, the data acquired is in the form of unit QTS as presented in @sec-quaternions.

![Sensor positionned on the right hip.](images/sensor-position.png){#fig-sensor-position width=150}

We asked the participants to walk on the GAITRite® mat, a gold standard in gait analysis [@Menz2004] while wearing the IMU sensor on their right hip. This choice, required to have a labeling of gait events from the walkway, constrained the path followed by the participants to a straight line of approximately nine meters. The GAITRite® device gives various information thanks to pressure sensors contained in the mat such as the time points where the subject feet touch and leave the ground at each step, which are exactly the gait events of interest to train our segmentation models for the IMU sensor. To use the two devices simultaneously, they were started at the same time by the same person with their two index fingers, allowing a good synchronization between devices [@de1992stability]. Also, we asked the participants to wait for three seconds before starting to walk on the mat to ensure that the sensor was properly calibrated and stable before walking.

We included six subjects in this study (three men and three women) of different ages and walking at different speeds to have a variety of gait data. @tbl-subjects summarized the demographic characteristics of the participants. We recorded a total of 174 walking sessions between June and September 2024. The data has been publicly released [@bellanger_2026_18222246]. We can therefore download it and store it in an R object for use in the rest of this document.

```{r}
#| label: tbl-subjects
#| tbl-cap: "Summary of subjects and walking speeds used to train the model."
#| tbl-pos: "H"
# bhg <- readRDS(url(
#   "https://zenodo.org/records/18222246/files/bellier_healthy_gait.rds?download=1"
# ))
bhg <- readRDS("~/Downloads/bhg.rds")

bhg |>
  dplyr::group_by(subject, gender, age, condition) |>
  dplyr::summarise(speed = round(mean(speed), digits = 0), .groups = "drop") |>
  tidyr::pivot_wider(names_from = condition, values_from = speed) |>
  janitor::clean_names() |>
  dplyr::select(
    id = subject,
    gender,
    age,
    slow,
    intermediate,
    preferential = base,
    fast
  ) |>
  dplyr::mutate_at(dplyr::vars(slow:fast), as.integer) |>
  gt::gt() |>
  gt::tab_spanner(
    label = "Walking speed (cm/s)",
    columns = c(slow, intermediate, preferential, fast)
  ) |>
  gt::cols_label(
    id = "ID",
    gender = "Gender",
    age = "Age range",
    slow = "Slow",
    intermediate = "Intermediate",
    preferential = "Preferential",
    fast = "Fast"
  ) |>
  gt::cols_units(
    age ~ "years",
    .units_pattern = "{1} ({2})"
  ) |>
  gt::sub_missing() |>
  gt_custom_theme()
```

## IMU data {#sec-imu-data}

### Raw IMU data

As mentioned before, the IMU records the orientation of the device over time in the form of a unit QTS every 10 milliseconds. The four coordinates match the definition of a quaternion provided in @eq-quaternions. This data is stored in the list-column `bhg$egait`.

::: {.callout-tip title="The [{squat}](https://lmjl-alea.github.io/squat/) package"}
We developed a dedicated R package coined [{squat}](https://lmjl-alea.github.io/squat/) for **S**tatistics for **QUA**ternion **T**emporal Data which defines a specific data structure of class `qts` to store and manipulate unit QTS data. In particular, `bhg$egait` is a list of objects of class `qts` which stores the IMU sensor data that we collected. An object of class `qts` is a [tibble](https://tibble.tidyverse.org/) with five columns: a *time* column and four columns for the quaternion coordinates named *w*, *x*, *y* and *z*.
:::

We first need to filter out the initial three seconds of data where the subject is standing still before walking on the mat. This can be achieved using the `dplyr::filter()` function. For visualization purposes, we then implemented both a `graphics::plot()` and `ggplot2::autoplot()` S3 specializations for objects of class `qts` in [{squat}](https://cran.r-project.org/package=squat). Many other S3 specializations and methods for objects of class `qts` are available as explained in the dedicated website[^squat-website]. Below, we use the `autoplot` S3 specialization to produce @fig-raw-qts which shows an example of QTS from the data set `bhg`.

[^squat-website]: <https://lmjl-alea.github.io/squat/>.

```{r}
#| label: fig-raw-qts
#| fig-cap: "Raw data recorded by the IMU sensor as a 4-coordinate unit QTS."
#| fig-pos: "H"
bhg$egait <- lapply(
  bhg$egait,
  \(qts) {
    dplyr::filter(qts, time > 3)
  }
)
bhg$egait[[33]] |>
  autoplot() +
  theme_bw() +
  labs(title = "", x = "Time (seconds)")
```

It is important to observe that @fig-raw-qts displays the gait of a healthy person with nicely depicted gait cycles that are consistent over time. Impaired gait will not necessarily exhibit the same regularity.

### Centered IMU data

A centring step is applied on the QTS to mitigate sensor shifts in position along the belt. This preprocessing step ensures that the mean quaternion of each QTS is the identity. In details, let $\mathbf{Q}_1, \dots, \mathbf{Q}_n$ be $n$ QTS observed on the same time grid $t_1 < t_2 < \dots < t_p$. Recall that we write $\mathbf{Q}_i(t_j) = \mathbf{q}_{ij} \in \mathbb{H}_u$, for any $i \in [\![ 1, n ]\!]$ and $j \in [\![ 1, p ]\!]$. We use the Fréchet mean associated to the geodesic distance $d_g$ (see @eq-geodesic-distance) to compute the mean $\mathbf{q}_j^{(m)}$ of all quaternions $\mathbf{q}_{1j}, \dots, \mathbf{q}_{nj}$ at a given time point $t_j$:

$$
\mathbf{q}_j^{(m)} = \underset{\mathbf{q} \in \mathbb{H}_u}{\mathrm{argmin}} \sum_{i=1}^n d_g^2(\mathbf{q}_{ij}, \mathbf{q}), \hspace{5mm} j \in [\![ 1, p ]\!].
$$ {#eq-mean-qts}

Numerically, @eq-mean-qts is solved iteratively following algorithms proposed in @moakher02 and @manton04. The centered QTS $\mathbf{Q}_1^{(c)}, \dots, \mathbf{Q}_n^{(c)}$ can then be computed as:

$$
\mathbf{q}_{ij}^{(c)} = \mathbf{Q}_i^{(c)} (t_j) = \left( \mathbf{q}_j^{(m)} \right)^{-1} \mathbf{q}_{ij}, \hspace{5mm} j \in [\![ 1, p ]\!],\hspace{2mm}  i \in [\![ 1, n ]\!].
$$ {#eq-centring-qts}

From a practical perspective, the centring step can be performed by applying the `squat::centring()` function to each element of the list-column `bhg$egait`:

```{r}
#| label: fig-centered-qts
#| fig-cap: "Raw data recorded by the IMU sensor after application of the centering step."
#| fig-pos: "H"
bhg$egait <- lapply(
  bhg$egait,
  \(qts) {
    squat::centring(qts)
  }
)
bhg$egait[[33]] |>
  autoplot() +
  theme_bw() +
  labs(title = "", x = "Time (seconds)")
```

@fig-centered-qts shows the same unit QTS as exhibited in @fig-raw-qts after the centring step. It has the effect of centering quaternions around the neutral element $(1,0,0,0)$ of the Lie group which is visible notably on the $w$ component.

### Smoothed IMU data

The raw (or centered) QTS data recorded by the sensor can be noisy due to small movements of the sensor during walking or electronic noise. To reduce this noise, we applied a smoothing step on the centered QTS using cubic splines. This step requires to choose a smoothness parameter that controls the amount of smoothing applied to the original data. A higher value of this parameter results in a smoother QTS but may also remove relevant information. In details, we fit a smoothing cubic spline representation $\mathbf{v}_s$ to each component of the logarithm $\mathbf{v} = \ln \mathbf{q}(t)$ of the centered QTS independently using the `smooth.spline()` from the `R` {stats} package. The functional representation of the QTS itself is then obtained by exponentiating the smoothed logarithm back to the unit quaternion space which reads:

$$
\mathbf{q}_s (t) = \exp \mathbf{v}_s (t), \text{ where } \mathbf{v}(t) = \ln \mathbf{q}(t).
$$ {#eq-smoothed-qts}

We used the default settings of the `stats::smooth.spline()` function except for the *spar* parameter which we tuned as a hyper-parameter (see @sec-feature-space). The code below shows the steps required to perform the smoothing step for a given value of the *spar* parameter:

```{r}
#| label: fig-smoothed-qts
#| fig-cap: "Smoothed version of a centered QTS."
#| fig-pos: "H"
spar <- 0.3 # example value for the spar parameter
log_qts <- log(bhg$egait[[33]])
smoothed_log_qts <- as_qts(dplyr::tibble(
  time = log_qts$time,
  w = 0,
  x = stats::smooth.spline(log_qts$time, log_qts$x, spar = spar)$y,
  y = stats::smooth.spline(log_qts$time, log_qts$y, spar = spar)$y,
  z = stats::smooth.spline(log_qts$time, log_qts$z, spar = spar)$y
))
smoothed_qts <- exp(smoothed_log_qts)
smoothed_qts |>
  autoplot() +
  theme_bw() +
  labs(title = "", x = "Time (seconds)")
```

The code above illustrates some other nice S3 specializations implemented in the [{squat}](https://cran.r-project.org/package=squat/) package such as the `log()` and `exp()` functions to compute the logarithm and exponential of a unit QTS respectively. As mentioned in @sec-quaternions, the logarithm of a unit quaternion has a null scalar part, which is why we set the *w* coordinate to zero in the code above and only smooth the three other coordinates. The function `squat::qts2sqts()` is dedicated to performing this exact computation. @fig-smoothed-qts nicely shows the smoothing effect with subtle variations along the curves that are smoothed out.

## Pressure mat data {#sec-gaitrite-data}

The GAITRite® mat records the positions of the feet on the mat through pressure-sensitive sensors hidden beneath the mat. It returns a table of spatio-temporal parameters such as stride duration, stride length, walking speed, etc. @tbl-gaitrite-params in the Appendix provides the exhaustive list of all spatio-temporal gait parameters that the walkway outputs. It also returns the time of each event happening during a gait cycle such as the time where a foot touches or leaves the ground. We specifically use this subset of the data collected by the GAITRite® mat to each timepoint of the IMU data. Specifically, as described in @sec-introduction and nicely summarized in @fig-walking-cycle, the gait events of interest are :

- *Right Heel Strike* (RHS) which corresponds to the moment when the right foot touches the ground for the first type;
- *Left Toe Off* (LTO) which corresponds to the moment when the left foot leaves the ground entirely;
- *Left Heel Strike* (LHS) which corresponds to the moment when the left foot touches the ground for the first type;
- *Right Toe Off* (RTO) which corresponds to the moment when the right foot leaves the ground entirely.

From these events, one can define phases within the gait cycle as follows:

- *Pre-Stance* phase: timespan between two consecutive RHS and LTO events;
- *Stance* phase: timespan between two consecutive LTO and LHS events;
- *Pre-Swing* phase: timespan between two consecutive LHS and RTO events;
- *Swing* phase: timespan between two consecutive RTO and RHS events.

The part of the raw data from the GAITRite® walkway that we kept for labeling the data is made of three variables:

```{r}
#| label: tbl-gaitrite
#| tbl-cap: "An illustration (33rd session) of the subset of GAITRite data used for detecting the key events for gait segmentation."
#| tbl-pos: "H"
bhg$gaitrite[[33]] |>
  dplyr::select(foot, first_contact, last_contact) |>
  dplyr::mutate(foot = as.integer(foot)) |>
  gt::gt() |>
  gt::cols_label(
    foot = "Foot",
    first_contact = "First Contact",
    last_contact = "Last Contact"
  ) |>
  gt::cols_units(
    gt::ends_with("contact") ~ "s",
    .units_pattern = "{1} ({2})"
  ) |>
  gt_custom_theme()
```

@tbl-gaitrite describes each occurence of a foot (`foot`: 0 for left foot, 1 for right foot) touching the ground, from the moment it touches it for the first time (`first_contact`) to the moment when it leaves it entirely (`last_contact`). Therefore, for instance, we can extract the RHS events by (i) filtering the table to keep only rows for which `foot == 1` and (ii) selecting the `first_contact` column which will contain exactly the times at which RHS events occured. The following piece of code performs exactly these steps:

An additional preprocessing step is required as part of the synchronization between the GAITRite® and IMU devices. In effect, while we setup a procedure to optimize synchronization, the procedure is only precise up to 5/10 milliseconds. Furthermore, the two devices have different frequencies. Hence, we need to match timepoints measured by the GAITRite® device to the closest timepoint measured by the IMU device.

```{r}
#| label: tbl-raw-gaitrite-data
#| tbl-cap: "Extraction of the occurence of the key gait events from the GAITRite data *before* suppressing uncorrectly labelled events (33rd session)."
#| tbl-subcap: ["First half", "Second half"]
#| tbl-pos: "H"
#| layout-ncol: 2
#| html-table-processing: none
match_gaitrite_to_imu_timepoints <- function(
  gaitrite_timepoints,
  imu_timepoints
) {
  keep <- gaitrite_timepoints >= min(imu_timepoints)
  keep <- keep & gaitrite_timepoints <= max(imu_timepoints)
  gaitrite_timepoints <- gaitrite_timepoints[keep]
  sort(purrr::map_dbl(gaitrite_timepoints, \(gaitrite_timepoint) {
    idx <- which.min(abs(imu_timepoints - gaitrite_timepoint))
    imu_timepoints[idx]
  }))
}

rhs <- purrr::map2(bhg$gaitrite, bhg$egait, \(.gaitrite, .imu) {
  .gaitrite |>
    dplyr::filter(foot == 1) |>
    dplyr::pull(first_contact) |>
    match_gaitrite_to_imu_timepoints(imu_timepoints = .imu$time)
})

lto <- purrr::map2(bhg$gaitrite, bhg$egait, \(.gaitrite, .imu) {
  .gaitrite |>
    dplyr::filter(foot == 0) |>
    dplyr::pull(last_contact) |>
    match_gaitrite_to_imu_timepoints(imu_timepoints = .imu$time)
})

lhs <- purrr::map2(bhg$gaitrite, bhg$egait, \(.gaitrite, .imu) {
  .gaitrite |>
    dplyr::filter(foot == 0) |>
    dplyr::pull(first_contact) |>
    match_gaitrite_to_imu_timepoints(imu_timepoints = .imu$time)
})

rto <- purrr::map2(bhg$gaitrite, bhg$egait, \(.gaitrite, .imu) {
  .gaitrite |>
    dplyr::filter(foot == 1) |>
    dplyr::pull(last_contact) |>
    match_gaitrite_to_imu_timepoints(imu_timepoints = .imu$time)
})

gaitrite_data <- purrr::map(1:nrow(bhg), \(index) {
  dplyr::bind_rows(
    tibble::tibble(
      event_time = rhs[[index]],
      event_type = rep("RHS", length(rhs[[index]]))
    ),
    tibble::tibble(
      event_time = lto[[index]],
      event_type = rep("LTO", length(lto[[index]]))
    ),
    tibble::tibble(
      event_time = lhs[[index]],
      event_type = rep("LHS", length(lhs[[index]]))
    ),
    tibble::tibble(
      event_time = rto[[index]],
      event_type = rep("RTO", length(rto[[index]]))
    )
  ) |>
    dplyr::arrange(event_time)
})

n_rows <- nrow(gaitrite_data[[33]])
n_rows_first <- ceiling(n_rows / 2)

gaitrite_data[[33]] |>
  dplyr::slice(1:n_rows_first) |>
  dplyr::select(event_type, event_time) |>
  gt::gt() |>
  gt::cols_label(
    event_type = "Event",
    event_time = "Time of Occurence"
  ) |>
  gt::cols_units(event_time ~ "s", .units_pattern = "{1} ({2})") |>
  gt_custom_theme()

gaitrite_data[[33]] |>
  dplyr::slice((n_rows_first + 1):n_rows) |>
  dplyr::select(event_type, event_time) |>
  gt::gt() |>
  gt::cols_label(
    event_type = "Event",
    event_time = "Time of Occurence"
  ) |>
  gt::cols_units(event_time ~ "s", .units_pattern = "{1} ({2})") |>
  gt_custom_theme()
```

@tbl-raw-gaitrite-data shows the list of consecutive gait events. One can observe that the natural order of the events (RHS $\to$ LTO $\to$ LHS $\to$ RTO) is sometimes broken, especially at the beginning and end of the walking session. Another important data pre-processing step therefore pertains to making sure that the retrieved events are ordered appropriately. The following chunk of code achieves this correction:

```{r}
#| label: tbl-preprocessed-gaitrite-data
#| tbl-cap: "Extraction of the occurence of the key gait events from the GAITRite data *after* suppressing uncorrectly labelled events (33rd session)."
#| tbl-subcap: ["First half", "Second half"]
#| tbl-pos: "H"
#| layout-ncol: 2
gaitrite_data <- gaitrite_data |>
  purrr::map(\(session_data) {
    phase_index <- 1
    session_data$phase <- rep(phase_index, nrow(session_data))
    for (i in 2:nrow(session_data)) {
      current_event <- session_data$event_type[i]
      previous_event <- session_data$event_type[i - 1]
      same_phase <- switch(
        current_event,
        "RHS" = previous_event == "RTO",
        "LTO" = previous_event == "RHS",
        "LHS" = previous_event == "LTO",
        "RTO" = previous_event == "LHS"
      )
      if (same_phase) {
        session_data$phase[i] <- phase_index
      } else {
        phase_index <- phase_index + 1
        session_data$phase[i] <- phase_index
      }
    }
    largest_phase_index <- session_data |>
      dplyr::count(phase) |>
      dplyr::pull(n) |>
      which.max()
    session_data |>
      dplyr::filter(phase == largest_phase_index) |>
      dplyr::select(-phase)
  })

n_rows <- nrow(gaitrite_data[[33]])
n_rows_first <- ceiling(n_rows / 2)

gaitrite_data[[33]] |>
  dplyr::slice(1:n_rows_first) |>
  dplyr::select(event_type, event_time) |>
  gt::gt() |>
  gt::cols_label(
    event_type = "Event",
    event_time = "Time of Occurence"
  ) |>
  gt::cols_units(event_time ~ "s", .units_pattern = "{1} ({2})") |>
  gt_custom_theme()

gaitrite_data[[33]] |>
  dplyr::slice((n_rows_first + 1):n_rows) |>
  dplyr::select(event_type, event_time) |>
  gt::gt() |>
  gt::cols_label(
    event_type = "Event",
    event_time = "Time of Occurence"
  ) |>
  gt::cols_units(event_time ~ "s", .units_pattern = "{1} ({2})") |>
  gt_custom_theme()
```

@tbl-preprocessed-gaitrite-data shows that, in the case of the $33$-*rd* walking session, this preprocessing step essentially suppressed the first and last events to guarantee the natural order of all remaining events. This is actually what the correction ended up doing for all walking sessions except for the $61$-*st* for which the first three events and the last one have been suppressed.

## Labelled IMU data {#sec-labelled-imu-data}

@sec-imu-data presented the preprocessed IMU data from which we aim at identifying the four key gait events (RHS, LTO, LHS, RTO) and @sec-gaitrite-data presented the preprocessed GAITRite data which provides the ground truth labels for each timepoint. We can now perform a table join use the timepoints as key variable to create the labelled IMU data that will serve as the basis for building the feature space for training supervised classification models. First, we observe that, as the obervations are ordered timepoints, it makes sense to include data *anterior* to the considered timepoint as features in addition to data from the considered timepoint but we cannot include data recorded *posterior* to the considered timepoint. This means that there is no need to keep IMU data collected *after* the last event detected in the GAITRite data. Similarly, we only keep the IMU data collected starting $10$ timepoints *before* the first event detected in the GAITRite data. This choice prescribes a lower bound to the lag interval that we will explore when training and tuning the classification models later on. Once this filtering step is achieved, we can perform the table join to add the event labels to the timepoints in the IMU data. @fig-labelled-imu-data produced by the code below shows the filtered IMU data with events of interest clearly identified by joining the GAITRite data.

```{r}
#| label: fig-labelled-imu-data
#| fig-cap: "Filtered IMU data (33rd session) with key gait events superimposed with colored points."
#| fig-pos: "H"
min_timepoints <- gaitrite_data |>
  purrr::map("event_time") |>
  purrr::map_dbl(min)
max_timepoints <- gaitrite_data |>
  purrr::map("event_time") |>
  purrr::map_dbl(max)

imu_data <- purrr::pmap(
  list(bhg$egait, min_timepoints, max_timepoints),
  \(.imu, .min_timepoint, .max_timepoint) {
    idx_min <- which(.imu$time == .min_timepoint)[1]
    idx_max <- which(.imu$time == .max_timepoint)[1]
    lower_bnd <- max(idx_min - 10, 1)
    upper_bnd <- min(idx_max, nrow(.imu))
    .imu[lower_bnd:upper_bnd, ]
  }
)

labelled_imu_data <- purrr::map2(
  imu_data,
  gaitrite_data,
  \(.imu, .gaitrite) {
    out <- .imu |>
      dplyr::left_join(.gaitrite, by = c("time" = "event_time")) |>
      dplyr::mutate(
        event_type = dplyr::if_else(is.na(event_type), "None", event_type),
        event_type = factor(
          event_type,
          levels = c("RHS", "LTO", "LHS", "RTO", "None")
        )
      )
    class(out) <- class(out)[-1]
    out
  }
)

df <- tidyr::pivot_longer(labelled_imu_data[[33]], cols = -c(time, event_type))

df |>
  ggplot(aes(x = time, y = value)) +
  geom_point(
    data = dplyr::filter(df, event_type != "None"),
    mapping = aes(color = event_type),
    size = 2
  ) +
  geom_line() +
  facet_wrap(vars(name), ncol = 1, scales = "free") +
  theme_bw() +
  labs(x = "Time (s)", y = "", color = "Events") +
  theme(legend.position = "top")
```